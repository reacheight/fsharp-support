options {
  parserPackage="JetBrains.ReSharper.Plugins.FSharp.Psi.Gen";
  parserClassName="FSharpParserGenerated";
  psiInterfacePackageName="JetBrains.ReSharper.Plugins.FSharp.Psi.Tree";
  psiStubsPackageName="JetBrains.ReSharper.Plugins.FSharp.Psi.Impl.Tree";
  psiStubsBaseClass="JetBrains.ReSharper.Plugins.FSharp.Psi.Impl.Tree.FSharpCompositeElement";
  tokenClassName="JetBrains.ReSharper.Plugins.FSharp.Psi.Impl.Tree.FSharpToken";
  tokenTypePackageName="JetBrains.ReSharper.Plugins.FSharp.Psi.Parsing";
  tokenTypeClassName="FSharpTokenType";
  parserTargetSubdir="Parsing/FSharp";
  psiInterfacesTargetSubdir="Psi/FSharp";
  psiStubsTargetSubdir="Psi/FSharp/Impl";
  elementTypePrefix="";
  visitorClassName="TreeNodeVisitor";
  visitorMethodSuffix="";
  disableReflection;
  separateHierarchies;
  acceptModifier="";
  visitorSuperClassName="JetBrains.ReSharper.Plugins.FSharp.Psi.TreeNodeVisitorBase";
  "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
  "leafElementClassFQName"="JetBrains.ReSharper.Plugins.FSharp.Psi.Impl.Tree.FSharpLeafElement";
  "compositeElementClassFQName"="JetBrains.ReSharper.Plugins.FSharp.Psi.Impl.Tree.FSharpCompositeElement";
  "psiElementVisitorClassFQName"="JetBrains.ReSharper.Plugins.FSharp.Psi.Tree.TreeNodeVisitor";
  "unexpectedTokenClassFQName"="Parsing.UnexpectedToken";
  "syntaxErrorClassFQName"="Parsing.SyntaxError";
  "parserGenRuntimePackageName"="Parsing";
  "createTokenElementMethodFQName"="JetBrains.ReSharper.Plugins.FSharp.Psi.Impl.Factory.createTokenElement";
  "visitMethodPrefix"="Visit";
  "lexerClassName"="JetBrains.ReSharper.Plugins.FSharp.Psi.Parsing.FSharpLexer";
  "psiClassesPrefix"="";
  "psiElementClassFQName"="JetBrains.ReSharper.Plugins.FSharp.Psi.Tree.IFSharpTreeNode";
  customImplPackage="JetBrains.ReSharper.Plugins.FSharp.Psi.Impl.Tree";
  customInterfacePackage="JetBrains.ReSharper.Plugins.FSharp.Psi.Tree";
  "interfaceNamePrefix"="I";
  "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";
  "customImplSuffix"="";
  "objectClassFQName"="System.Object";
  publicChildRolePrefix="FS_";
  tokenBitsetThreshold=4;
  elementTypeBaseClass="JetBrains.ReSharper.Plugins.FSharp.Psi.Tree.FSharpCompositeNodeType";
  parserMessagesClass="JetBrains.ReSharper.Plugins.FSharp.Psi.Parsing.ParserMessages";
  generateWorkingPsi;
}



// Files

interface fSharpFile options { customParseFunction; noInternalParseFunction; }:
  fSharpImplFile |
  fSharpSigFile;

fSharpImplFile options { customParseFunction; noInternalParseFunction; stubBase="FSharpFileBase"; }:
  (
    topLevelModuleLikeDeclaration<MODULE_OR_NAMESPACE_DECLARATION, ModuleDeclarations>*
  |
    anonModuleDeclaration<MODULE_OR_NAMESPACE_DECLARATION, ModuleDeclarations>
  );

fSharpSigFile options { stubBase="FSharpFileBase"; }:
  topLevelModuleLikeDeclaration<MODULE_OR_NAMESPACE_DECLARATION, ModuleDeclarations>*;


// Modules and namespaces

interface moduleLikeDeclaration:
  anonModuleDeclaration
  declaredModuleLikeDeclaration;

interface declaredModuleLikeDeclaration:
  topLevelModuleLikeDeclaration |
  nestedModuleDeclaration;

interface topLevelModuleLikeDeclaration:
  qualifiableModuleLikeDeclaration |
  globalNamespaceDeclaration;

interface qualifiableModuleLikeDeclaration:
  namedModuleDeclaration |
  namedNamespaceDeclaration;

interface moduleDeclaration:
  anonModuleDeclaration |
  declaredModuleDeclaration;

interface declaredModuleDeclaration:
  namedModuleDeclaration |
  nestedModuleDeclaration;

namedNamespaceDeclaration options { stubBase="FSharpDeclarationBase"; }:
  NAMESPACE<NAMESPACE, ModuleOrNamespaceKeyword>
  REC<REC, RecKeyword>?
  (
    referenceName<REFERENCE_NAME, QualifierReferenceName>
    DOT
  )?
  fSharpIdentifier<IDENTIFIER, Identifier>
  moduleMember<MODULE_MEMBER, Members>*;

globalNamespaceDeclaration options { stubBase="FSharpDeclarationBase"; }:
  NAMESPACE<NAMESPACE, ModuleOrNamespaceKeyword>
  REC<REC, RecKeyword>?
  GLOBAL<GLOBAL, GlobalKeyword>
  moduleMember<MODULE_MEMBER, Members>*;

namedModuleDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="Attributes" path=<namedModuleDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  MODULE<MODULE, ModuleOrNamespaceKeyword>
  REC<REC, RecKeyword>?
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  (
    referenceName<REFERENCE_NAME, QualifierReferenceName>
    DOT
  )?
  fSharpIdentifier<IDENTIFIER, Identifier>
  moduleMember<MODULE_MEMBER, Members>*;

anonModuleDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; }:
  moduleMember<MODULE_MEMBER, Members>*;



// Module members

interface moduleMember:
  nestedModuleDeclaration |
  fSharpTypeDeclaration |
  letModuleDecl |
  moduleAbbreviation |
  openStatement |
  do |
  hashDirective;

letModuleDecl options { stubBase="DummyDeclaration"; } extras {
  get { methodName="Attributes" path=<letModuleDecl:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  letOrUse{LET, LetOrUseToken}
  INLINE<INLINE, InlineKeyword>?
  REC<REC, RecKeyword>?
  binding<BINDING, Bindings>
  (
    AND<AND, Separators>
    binding<BINDING, Bindings>
  )*;


interface let:
  letBindings |
  letOrUseBangExpr;

interface letBindings:
  letModuleDecl |
  letOrUseExpr;

interface letLikeExpr:
  letOrUseExpr |
  letOrUseBangExpr;


interface binding:
  topBinding |
  localBinding;

topBinding extras {
  get { methodName="Expression" path=<topBinding:CHAMELEON_EXPR/chameleonExpression:EXPR> };
  get { methodName="Attributes" path=<topBinding:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  INLINE<INLINE, InlineKeyword>?
  MUTABLE<MUTABLE, MutableKeyword>?
  synPat<HEAD_PATTERN, HeadPattern>
  returnTypeInfo<RETURN_INFO, ReturnTypeInfo>?
  EQUALS
  chameleonExpression<CHAMELEON_EXPR, ChameleonExpression>;

localBinding extras {
  get { methodName="Attributes" path=<localBinding:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  INLINE<INLINE, InlineKeyword>?
  MUTABLE<MUTABLE, MutableKeyword>?
  synPat<HEAD_PATTERN, HeadPattern>
  returnTypeInfo<RETURN_INFO, ReturnTypeInfo>?
  EQUALS
  synExpr<EXPR, Expression>;

returnTypeInfo extras {
  get { methodName="Attributes" path=<returnTypeInfo:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  COLON
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  synType<TYPE, ReturnType>;

interface synPat:
  namedPat |
  typedPat |
  attribPat |
  orPat |
  andsPat |
  tuplePat |
  arrayOrListPat |
  parenPat |
  recordPat |
  optionalValPat |
  isInstPat |
  consPat |
  wildPat |
  constPat |
  fieldPat |
  otherPat;

interface namedPat:
  referencePat |
  parametersOwnerPat |
  asPat;

interface referencePat:
  localReferencePat |
  topReferencePat;

// todo: fix active pattern and operator decls
interface parametersOwnerPat:
  localParametersOwnerPat
  topParametersOwnerPat;

interface asPat:
  localAsPat |
  topAsPat;


localReferencePat options { stubBase="LocalPatternDeclarationBase"; }extras {
  get { methodName="Identifier" path=<localReferencePat:REFERENCE_NAME/expressionReferenceName:IDENTIFIER> };
}:
  expressionReferenceName<REFERENCE_NAME, ReferenceName>;

topReferencePat options { stubBase="TopPatternDeclarationBase"; } extras {
  get { methodName="Identifier" path=<topReferencePat:REFERENCE_NAME/expressionReferenceName:IDENTIFIER> };
}:
  expressionReferenceName<REFERENCE_NAME, ReferenceName>;

localParametersOwnerPat options { stubBase="LocalPatternDeclarationBase"; } extras {
  get { methodName="Identifier" path=<localParametersOwnerPat:REFERENCE_NAME/expressionReferenceName:IDENTIFIER> };
}:
  expressionReferenceName<REFERENCE_NAME, ReferenceName>
  synPat<PARAMETER, Parameters>*;

topParametersOwnerPat options { stubBase="TopPatternDeclarationBase"; } extras {
  get { methodName="Identifier" path=<topParametersOwnerPat:REFERENCE_NAME/expressionReferenceName:IDENTIFIER> };
}:
  expressionReferenceName<REFERENCE_NAME, ReferenceName>
  synPat<PARAMETER, Parameters>*;

localAsPat options { stubBase="LocalPatternDeclarationBase"; }:
  synPat<PATTERN, Pattern>
  AS
  fSharpIdentifier<IDENTIFIER, Identifier>;

topAsPat options { stubBase="TopPatternDeclarationBase"; }:
  synPat<PATTERN, Pattern>
  AS
  fSharpIdentifier<IDENTIFIER, Identifier>;


interface arrayOrListPat:
  arrayPat |
  listPat;

typedPat options { stubBase="SynPatternBase"; }:
  synPat<PATTERN, Pattern>
  COLON
  synType<TYPE, Type>;

attribPat options { stubBase="SynPatternBase"; } extras {
  get { methodName="Attributes" path=<attribPat:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  synPat<PATTERN, Pattern>;

orPat options { stubBase="SynPatternBase"; }:
  synPat<PATTERN1, Pattern1>
  BAR
  synPat<PATTERN2, Pattern2>;

andsPat options { stubBase="SynPatternBase"; }:
  synPat<PATTERN1, Pattern1>
  AMP
  synPat<PATTERN2, Pattern2>;

arrayPat options { stubBase="SynPatternBase"; }:
  LBRACK_BAR
  synPat<ATTRIBUTE, Patterns>*
  LBRACK_BAR;

listPat options { stubBase="SynPatternBase"; }:
  LBRACK
  synPat<ATTRIBUTE, Patterns>*
  RBRACK;

tuplePat options { stubBase="SynPatternBase"; }:
  synPat<ATTRIBUTE, Patterns>
  (
    COMMA
    synPat<ATTRIBUTE, Patterns>
  )*;

parenPat options { stubBase="SynPatternBase"; }:
  LPAREN
  synPat<PATTERN, Pattern>
  RPAREN;

recordPat options { stubBase="SynPatternBase"; }:
  LBRACE
  fieldPat<FIELD_PAT, FieldPatterns>*
  RBRACE;

fieldPat options { stubBase="SynPatternBase"; }:
  expressionReferenceName<REFERENCE_NAME, ReferenceName>
  EQUALS
  synPat<PAT, Pattern>;

optionalValPat options { stubBase="SynPatternBase"; }:
  QMARK
  synPat<PATTERN, Pattern>;

isInstPat options { stubBase="SynPatternBase"; }:
  COLON_QMARK
  synType<SYN_TYPE, Type>;

consPat options { stubBase="SynPatternBase"; }:
  synPat<PATTERN1, Pattern1>
  COLON_COLON
  synPat<PATTERN2, Pattern2>;

wildPat options { stubBase="SynPatternBase"; }:
  UNDERSCORE;

constPat options { stubBase="SynPatternBase"; }:
  (
    TRUE |
    FALSE |
    STRING // todo: add more
  );
  

otherPat options { stubBase="SynPatternBase"; }:
  fakeSeparator;


interface synExpr:
  parenExpr |
  quoteExpr |
  constExpr |
  typedExpr |
  tupleExpr |
  anonRecdExpr |
  arrayOrListExpr |
  recordExpr |
  newExpr |
  objExpr |
  whileExpr |
  forExpr |
  forEachExpr |
  arrayOrListOfSeqExpr |
  compExpr |
  lambdaExpr |
  matchLikeExpr |
  doExpr |
  assertExpr |
  appExpr |
  letLikeExpr |
  tryLikeExpr |
  lazyExpr |
  sequentialExpr |
  ifThenElseExpr |
  referenceExpr |
  setExpr |
  indexerExpr |
  typeTestExpr |
  castExpr |
  inferredCastExpr |
  nullExpr |
  addressOfExpr |
  traitCallExpr |
  joinInExpr |
  implicitZeroExpr |
  yieldOrReturnExpr |

  // todo: cover cases
  libraryOnlyExpr |
  fromErrorExpr |

  fixedExpr;

interface appExpr:
  prefixAppExpr |
  infixAppExpr;

setExpr options { stubBase="FSharpExpressionBase"; }:
  synExpr<LEFT_EXPR, LeftExpression>
  LARROW<LARROW, LArrow>
  synExpr<RIGHT_EXPR, RightExpression>;

interface indexerExpr:
  itemIndexerExpr |
  namedIndexerExpr;

itemIndexerExpr options { stubBase="FSharpExpressionBase"; } extras {
  get { methodName="Args" path=<itemIndexerExpr:ARG_LIST/indexerArgList:INDEXER_ARG> };
}:
  synExpr<EXPR, Expression>
  DOT
  indexerArgList<ARG_LIST, IndexerArgList>;

namedIndexerExpr options { stubBase="FSharpExpressionBase"; } extras {
  // todo: fix this, it's always empty now
  get { methodName="Args" path=<namedIndexerExpr:INDEXER_ARG> };
}:
  // todo: maybe: expr, dot, ident, arg?
  referenceExpr<EXPR, Expression>
  indexerArg<INDEXER_ARG, IndexerArg>;

indexerArgList:
  LBRACK
  synExpr<INDEXER_ARG, IndexerArgs>
    (
      COMMA
      synExpr<INDEXER_ARG, IndexerArgs>
    )*
  RBRACK;

indexerArg:
  synExpr<EXPR, Expressions>
  (
    DOT_DOT
    synExpr<EXPR, Expressions>
  )?;

interface castExpr:
  upcastExpr |
  downcastExpr;

parenExpr options { stubBase="FSharpExpressionBase"; }:
  LPAREN<LPAREN, LeftParen>
  synExpr<EXPR, InnerExpression>?
  RPAREN<RPAREN, RightParen>;

quoteExpr options { stubBase="FSharpExpressionBase"; }:
  (
    LQUOTE_TYPED
    synExpr<EXPR, QuotedExpression>?
    RQUOTE_TYPED?
  ) |
  (
    LQUOTE_UNTYPED
    synExpr<EXPR, QuotedExpression>?
    RQUOTE_UNTYPED?
  );

constExpr options { stubBase="FSharpExpressionBase"; }:
  fakeSeparator;

typedExpr options { stubBase="FSharpExpressionBase"; }:
  synExpr<EXPR, Expression>
  COLON
  synType<TYPE, Type>;

tupleExpr options { stubBase="FSharpExpressionBase"; }:
  (
    LPAREN
    STRUCT<STRUCT, StructKeyword>
  )?
  synExpr<EXPR, Expressions>
  (
    synExpr<EXPR, Expressions>
    COMMA
  )*;

anonRecdExpr options { stubBase="FSharpExpressionBase"; }:
  STRUCT<STRUCT, STRUCT_KEYWORD>?
  LBRACE_BAR
  (
    synExpr<COPY_INFO, CopyInfoExpression>
    WITH
  )?
  recordExprBinding<BINDING, ExprBindings>*
  BAR_RBRACE;

arrayOrListExpr options { stubBase="FSharpExpressionBase"; }:
  (
    LBRACK
    synExpr<EXPR, Expressions>*
    RBRACK
  ) |
  (
    LBRACK_BAR
    synExpr<EXPR, Expressions>*
    BAR_RBRACK
  );

recordExpr options { stubBase="FSharpExpressionBase"; }:
  LBRACE<LBRACE, LeftBrace>
  (
    synExpr<COPY_INFO, CopyInfoExpression>
    WITH
  )?
  recordExprBinding<BINDING, ExprBindings>*
  RBRACE<RBRACE, RightBrace>;

recordExprBinding:
  expressionReferenceName<REFERENCE_NAME, ReferenceName>
  EQUALS
  synExpr<EXPR, Expression>
  SEMICOLON<SEMI, Semicolon>?;

newExpr options { stubBase="FSharpExpressionBase"; }:
  NEW<NEW, NewKeyword>
  typeReferenceName<TYPE_REFERENCE, TypeName>
  synExpr<EXPR, ArgExpression>;

forExpr options { stubBase="FSharpExpressionBase"; }:
  FOR
  IDENTIFIER<IDENTIFIER, Identifier>
  synExpr<IDENT_EXPR, IdentExpression>
  TO
  synExpr<TO_EXPR, ToExpression>
  DO
  synExpr<DO_EXPR, DoExpression>;

forEachExpr options { stubBase="FSharpExpressionBase"; }:
  FOR
  synPat<PAT, Pattern>
  IN
  synExpr<IN_EXPR, InExpression>
  DO
  synExpr<DO_EXPR, DoExpression>;

arrayOrListOfSeqExpr options { stubBase="FSharpExpressionBase"; }:
  (LBRACK
   synExpr<EXPR, Expression>
   RBRACK) |

   (LBRACK_BAR
    synExpr<EXPR, Expression>
    BAR_RBRACK);

whileExpr options { stubBase="FSharpExpressionBase"; }:
  WHILE
  synExpr<WHILE_EXPR, WhileExpression>
  DO
  synExpr<DO_EXPR, DoExpression>;

objExpr options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="InterfaceMembers" path=<objExpr:INTERFACE_IMPL/interfaceImplementation:MEMBER_DECL> };
}:
  LBRACE
  NEW
  typeReferenceName<TYPE_REFERENCE, TypeName>
  synExpr<ARG_EXPR, ArgExpression>
  WITH
  memberDeclaration<MEMBER_DECL, MemberDeclarations>*
  interfaceImplementation<INTERFACE_IMPL, InterfaceImplementations>*
  RBRACE;

compExpr options { stubBase="FSharpExpressionBase"; }:
  LBRACE
  synExpr<EXPR, Expression>
  RBRACE;

lambdaExpr options { stubBase="FSharpExpressionBase"; }:
  FUN
  synPat<PAT, Patterns>*
  RARROW
  synExpr<EXPR, Expression>;

interface matchLikeExpr:
  matchExpr |
  matchLambdaExpr;

matchLambdaExpr options { stubBase="FSharpExpressionBase"; }:
  FUNCTION
  matchClause<MATCH_CLAUSE, Clauses>*;

// todo: separate nodes for bang exprs?
matchExpr options { stubBase="FSharpExpressionBase"; }:
  MATCH
  synExpr<EXPR, Expression>
  WITH
  matchClause<MATCH_CLAUSE, Clauses>*;

doExpr options { stubBase="FSharpExpressionBase"; }:
  DO
  synExpr<EXPR, Expression>;

assertExpr options { stubBase="FSharpExpressionBase"; }:
  ASSERT
  synExpr<EXPR, Expression>;

prefixAppExpr options { stubBase="FSharpExpressionBase"; }:
  synExpr<FUNC_EXPR, FunctionExpression>
  synExpr<ARG_EXPR, ArgumentExpression>;

infixAppExpr options { stubBase="FSharpExpressionBase"; }:
  synExpr<ARG_EXPR, ArgumentExpression>
  synExpr<FUNC_EXPR, FunctionExpression>;

letOrUseExpr options { stubBase="FSharpExpressionBase"; }:
  letOrUse{LET, LetOrUseToken}
  REC<REC, RecKeyword>?
  binding<BINDING, Bindings>
  (
    AND<AND, Separators>
    binding<BINDING, Bindings>
  )*
  IN<IN, InKeyword>?
  synExpr<IN_EXPR, InExpression>;

interface tryLikeExpr:
  tryWithExpr |
  tryFinallyExpr;

tryWithExpr options { stubBase="FSharpExpressionBase"; }:
  TRY
  synExpr<TRY_EXPR, TryExpression>
  WITH
  matchClause<CLAUSE, WithCases>*;

tryFinallyExpr options { stubBase="FSharpExpressionBase"; }:
  TRY
  synExpr<TRY_EXPR, TryExpression>
  FINALLY
  synExpr<FINALLY_EXPR, FinallyExpression>;

lazyExpr options { stubBase="FSharpExpressionBase"; }:
  LAZY
  synExpr<EXPR, Expression>;

sequentialExpr options { stubBase="FSharpExpressionBase"; }:
  synExpr<EXPR, Expressions>
  (
    SEMICOLON<SEMI, Separator>?
    synExpr<EXPR, Expressions>
  )*;

ifThenElseExpr options { stubBase="FSharpExpressionBase"; }:
  IF<IF, IfKeyword>
  synExpr<IF_EXPR, IfExpr>
  THEN<THEN, ThenKeyword>
  synExpr<THEN_EXPR, ThenExpr>
  (
    ELSE<ELSE, ElseKeyword>
    synExpr<ELSE_EXPR, ElseExpr>
  )?;

referenceExpr options { stubBase="FSharpExpressionBase"; } extras {
  get { methodName="TypeArguments" path=<referenceExpr:TYPE_ARG_LIST/prefixAppTypeArgumentList:TYPE> };
}:
  (
    synExpr<QUALIFIER_EXPR, Qualifier>
    DOT
  )?
  fSharpIdentifier<IDENTIFIER, Identifier>
  prefixAppTypeArgumentList<TYPE_ARG_LIST, TypeArgumentsList>?;

matchClause:
  BAR<BAR, Bar>?
  synPat<PAT, Pattern>
  (
    WHEN<WHEN, WhenKeyword>
    synExpr<WHEN_EXPR, WhenExpression>
  )?
  RARROW<RARROW, RArrow>
  synExpr<EXPR, Expression>;

typeTestExpr options { stubBase="FSharpExpressionBase"; }:
  synExpr<EXPR, Expression>
  COLON_QMARK
  synType<TYPE, Type>;

upcastExpr options { stubBase="FSharpExpressionBase"; }:
  synExpr<EXPR, Expression>
  COLON_GREATER<OP, OperatorToken>
  synType<TYPE, Type>;
  
downcastExpr options { stubBase="FSharpExpressionBase"; }:
  synExpr<EXPR, Expression>
  COLON_QMARK_GREATER
  synType<TYPE, Type>;

inferredCastExpr options { stubBase="FSharpExpressionBase"; }:
  (UPCAST | DOWNCAST)
  synExpr<EXPR, Expression>;

// todo: maybe replace with SynExpr.Const in FCS?
nullExpr options { stubBase="FSharpExpressionBase"; }:
  NULL<NULL, NullKeyword>;

addressOfExpr options { stubBase="FSharpExpressionBase"; }:
  (AMP | AMP_AMP)
  synExpr<EXPR, Expression>;

traitCallExpr options { stubBase="FSharpExpressionBase"; }:
  fakeSeparator;

joinInExpr options { stubBase="FSharpExpressionBase"; }:
  fakeSeparator;

implicitZeroExpr options { stubBase="FSharpExpressionBase"; }:
  fakeSeparator;

yieldOrReturnExpr options { stubBase="FSharpExpressionBase"; }:
  (YIELD | YIELD_BANG | RETURN | RETURN_BANG)
  synExpr<EXPR, Expression>;

letOrUseBangExpr options { customImpl; stubBase="FSharpExpressionBase"; } extras {
  get { methodName="Bindings" path=<letOrUseBangExpr:BINDING> };
}:
  letOrUseBang{LET, LetOrUseToken}
  binding<BINDING, Binding>
  IN<IN, InKeyword>?
  synExpr<IN_EXPR, InExpression>;

libraryOnlyExpr options { stubBase="FSharpExpressionBase"; }:
  fakeSeparator;

fromErrorExpr options { stubBase="FSharpExpressionBase"; }:
  fakeSeparator;

fixedExpr options { stubBase="FSharpExpressionBase"; }:
  FIXED<FIXED, FixedKeyword>
  synExpr<EXPR, Expression>;

chameleonExpression:
  synExpr<EXPR, Expression>;


interface fSharpTypeDeclaration:
  exceptionDeclaration |
  simpleTypeDeclaration |
  typeExtensionDeclaration |
  delegateDeclaration |
  objectModelTypeDeclaration |
  nestedTypeUnionCaseDeclaration;

interface simpleTypeDeclaration:
  enumDeclaration |
  recordDeclaration |
  unionDeclaration |
  notCompiledTypeDeclaration;

interface notCompiledTypeDeclaration:
  typeAbbreviationDeclaration |
  moduleAbbreviation |
  abstractTypeDeclaration |
  otherSimpleTypeDeclaration;

interface objectModelTypeDeclaration:
  classDeclaration |
  interfaceDeclaration |
  structDeclaration |
  objectTypeDeclaration;

nestedModuleDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="Attributes" path=<nestedModuleDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  MODULE<MODULE, ModuleOrNamespaceKeyword>
  REC<REC, RecKeyword>?
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  fSharpIdentifier<IDENTIFIER, Identifier>
  EQUALS
  moduleMember<MODULE_MEMBER, Members>*;

typeExtensionDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
   get { methodName="TypeParameters" path=<typeExtensionDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
   get { methodName="TypeMembers" path=<typeExtensionDeclaration:TYPE_MEMBER> };
   get { methodName="Attributes" path=<typeExtensionDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
 }:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  (
    referenceName<REFERENCE_NAME, QualifierReferenceName>
    DOT
  )?
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

// Enums

enumDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<enumDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<enumDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  enumMemberDeclaration<ENUM_MEMBER, EnumMembers>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

enumMemberDeclaration options { stubBase="FSharpProperTypeMemberDeclarationBase"; } extras {
  get { methodName="Attributes" path=<enumMemberDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  IDENTIFIER<IDENTIFIER, Identifier>;



// Records

recordDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<recordDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<recordDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  recordFieldDeclaration<RECORD_FIELD, Fields>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;


recordFieldDeclaration options { stubBase="FSharpProperTypeMemberDeclarationBase"; } extras {
  get { methodName="Attributes" path=<recordFieldDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  MUTABLE<MUTABLE, MutableKeyword>?
  IDENTIFIER<IDENTIFIER, Identifier>
  COLON
  synType<TYPE, Type>;



// Discriminated unions

unionCasesList:
  accessModifier{ACCESS_MODIFIER, Modifier}?
  unionCaseDeclaration<UNION_CASE, UnionCases>*;

unionDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<unionDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="UnionCases" path=<unionDeclaration:UNION_CASES_LIST/unionCasesList:UNION_CASE> };
  get { methodName="Attributes" path=<unionDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  unionCasesList<UNION_CASES_LIST, UnionCasesList>
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;


interface unionCaseDeclaration:
  singletonCaseDeclaration |
  nestedTypeUnionCaseDeclaration;

singletonCaseDeclaration options { stubBase="FSharpProperTypeMemberDeclarationBase"; } extras {
  get { methodName="Attributes" path=<singletonCaseDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>;

nestedTypeUnionCaseDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<nestedTypeUnionCaseDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<nestedTypeUnionCaseDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  caseFieldDeclaration<UNION_FIELD, Fields>*
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;


interface caseFieldDeclaration:
  unionCaseFieldDeclaration |
  exceptionFieldDeclaration;

unionCaseFieldDeclaration options { stubBase="UnionCaseFieldDeclarationBase"; }:
  IDENTIFIER<IDENTIFIER, Identifier>?
  synType<TYPE, Type>;

exceptionFieldDeclaration options { stubBase="UnionCaseFieldDeclarationBase"; }:
  IDENTIFIER<IDENTIFIER, Identifier>?
  synType<TYPE, Type>;


// Other members

exceptionDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<exceptionDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<exceptionDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  caseFieldDeclaration<UNION_FIELD, Fields>*
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

typeAbbreviationDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<typeAbbreviationDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<typeAbbreviationDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  EQUALS
  synType<TYPE, AbbreviatedType>
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

moduleAbbreviation options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<moduleAbbreviation:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<moduleAbbreviation:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  MODULE<MODULE, ModuleOrNamespaceKeyword>
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  EQUALS
  typeReferenceName<TYPE_REFERENCE, TypeName>
  // todo: remove rules below
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

interface activePatternCaseDeclaration:
  activePatternNamedCaseDeclaration |
  activePatternWildCase;

interface activePatternNamedCaseDeclaration:
  topActivePatternCaseDeclaration |
  localActivePatternCaseDeclaration;

topActivePatternCaseDeclaration options { stubBase="FSharpDeclarationBase"; }:
   IDENTIFIER<IDENTIFIER, Identifier>;

localActivePatternCaseDeclaration options { stubBase="LocalDeclarationBase"; }:
  IDENTIFIER<IDENTIFIER, Identifier>;

activePatternWildCase:
  wildPat;


otherSimpleTypeDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<otherSimpleTypeDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<otherSimpleTypeDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

abstractTypeDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<abstractTypeDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<abstractTypeDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;


// Object model type declarations

classDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<classDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<classDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

interfaceDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<interfaceDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<interfaceDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

structDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<structDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<structDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

objectTypeDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<objectTypeDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<objectTypeDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

delegateDeclaration options { stubBase="FSharpTypeElementDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<delegateDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfTypeList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<delegateDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfTypeList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  fSharpTypeMemberDeclaration<TYPE_MEMBER, TypeMembers>*;

interface fSharpTypeMemberDeclaration:
  constructorDeclaration |
  inheritMember |
  interfaceImplementation |
  abstractSlot |
  memberDeclaration |
  typeLetBindings |
  valField |
  autoProperty |
  letModuleDecl |

  otherTypeMember;

interface constructorDeclaration:
  implicitConstructorDeclaration |
  memberConstructorDeclaration;

interface inheritMember:
  typeInherit |
  interfaceInherit;

interfaceInherit:
  INHERIT
  typeReferenceName<TYPE_REFERENCE, TypeName>;

typeInherit options { stubBase="ReferenceOwnerBase"; }:
  INHERIT
  typeReferenceName<TYPE_REFERENCE, TypeName>
  chameleonExpression<CHAMELEON_EXPR, CtorArg>;

interfaceImplementation:
  INTERFACE
  typeReferenceName<TYPE_REFERENCE, TypeName>
  (
    WITH
    memberDeclaration<MEMBER_DECL, TypeMembers>*
  )?;


otherTypeMember: fakeSeparator;
typeLetBindings: fakeSeparator;

implicitConstructorDeclaration options { stubBase="FSharpProperTypeMemberDeclarationBase"; } extras {
  get { methodName="Parameters" path=<implicitConstructorDeclaration:PARAM_GROUP/memberParamDeclarationGroup:PARAMETER> };
}:
  memberParamDeclarationGroup<PARAM_GROUP, ParameterGroup>
  ctorSelfId<SELF_ID, SelfIdentifier>?;

interface selfId:
  ctorSelfId |
  memberSelfId;

ctorSelfId options { stubBase="LocalDeclarationBase"; }:
  AS
  IDENTIFIER<IDENTIFIER, Identifier>;

memberSelfId options { stubBase="LocalDeclarationBase"; }:
  IDENTIFIER<IDENTIFIER, Identifier>;  

memberConstructorDeclaration options { stubBase="FSharpProperTypeMemberDeclarationBase"; }:
  NEW<NEW, NewKeyword>
  localDeclaration<PARAMETER, Parameters>* fakeSeparator
  ctorSelfId<SELF_ID, SelfIdentifier>?;



// todo: fix properties with explicit setters

memberDeclaration options { stubBase="FSharpProperTypeMemberDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<memberDeclaration:TYPE_PARAMETERS_LIST/typeParameterOfMethodList:TYPE_PARAMETER> };
  get { methodName="Parameters" path=<memberDeclaration:PARAM_GROUP/memberParamDeclarationGroup:PARAMETER> };
  get { methodName="Attributes" path=<memberDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  accessModifier{ACCESS_MODIFIER, AccessModifiers}*
  memberSelfId<SELF_ID, SelfId>?
  identOrOpName{IDENTIFIER, Identifier}
  typeParameterOfMethodList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  (
    memberParamDeclarationGroup<PARAM_GROUP, ParameterGroups>*
    EQUALS
    chameleonExpression
  |
    WITH
    accessorDeclaration
    (
      AND
      accessorDeclaration
    )?
  );

abstractSlot options { stubBase="FSharpProperTypeMemberDeclarationBase"; } extras {
  get { methodName="TypeParameters" path=<abstractSlot:TYPE_PARAMETERS_LIST/typeParameterOfMethodList:TYPE_PARAMETER> };
  get { methodName="Attributes" path=<abstractSlot:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  IDENTIFIER<IDENTIFIER, Identifier>
  typeParameterOfMethodList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  memberParamDeclaration<PARAMETER, Parameters>*;

valField options { stubBase="FSharpProperTypeMemberDeclarationBase"; } extras {
  get { methodName="Attributes" path=<valField:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  IDENTIFIER<IDENTIFIER, Identifier>;

autoProperty options { stubBase="FSharpProperTypeMemberDeclarationBase"; }  extras {
  get { methodName="Expression" path=<autoProperty:CHAMELEON_EXPR/chameleonExpression:EXPR> };
  get { methodName="Attributes" path=<autoProperty:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  IDENTIFIER<IDENTIFIER, Identifier>
  EQUALS
  chameleonExpression<CHAMELEON_EXPR, InitExpression>
  accessorsNamesClause<ACESSORS_CLAUSE, AccessorsClause>?;

accessorsNamesClause:
  WITH
  (
    IDENTIFIER<ACESSOR, AccessorsNames>
  |
    IDENTIFIER<ACESSOR, AccessorsNames>
    COMMA
    IDENTIFIER<ACESSOR, AccessorsNames>
  );

accessorDeclaration:
  IDENTIFIER<IDENTIFIER, Identifier>
  memberParamDeclaration<PARAMETER, Parameters>*
  EQUALS
  chameleonExpression<CHAMELEON_EXPR, BodyExpression>;


memberParamDeclarationGroup:
  (
    memberParamDeclarationList
  |
    LPAREN
    memberParamDeclarationList
    RPAREN
  );
  
private memberParamDeclarationList:
  memberParamDeclaration<PARAMETER, Parameters>
  (
    COMMA
    memberParamDeclaration<PARAMETER, Parameters>
  )*;

memberParamDeclaration:
  synPat<PATTERN, Pattern>;


// module statements

interface hashDirective:
  lineDirective |
  loadDirective |
  referenceDirective |
  iDirective |
  otherDirective;

lineDirective:
  PP_LINE<PP_LINE, HashToken>
  STRING<STRING, Args>*;

loadDirective:
  PP_LOAD<PP_LOAD, HashToken>
  STRING<STRING, Args>*;

referenceDirective:
  PP_REFERENCE<PP_REFERENCE, HashToken>
  STRING<STRING, Args>*;

iDirective:
  PP_I<PP_I, HashToken>
  STRING<STRING, Args>*;

otherDirective:
  PP_DIRECTIVE<PP_DIRECTIVE, HashToken>
  STRING<STRING, Args>*;

openStatement:
  OPEN<OPEN, Open>
  typeReferenceName<TYPE_REFERENCE, ReferenceName>;

do options { stubBase="DummyDeclaration"; } extras {
    get { methodName="Attributes" path=<do:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
    get { methodName="Expression" path=<do:CHAMELEON_EXPR/chameleonExpression:EXPR> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  DO<DO, DoKeyword>?
  chameleonExpression<CHAMELEON_EXPR, DoExpression>;



// Identifiers

private letOrUse{ROLE, Getter}:
  LET<@ROLE, @Getter> |
  USE<@ROLE, @Getter>;

private letOrUseBang{ROLE, Getter}:
  LET_BANG<@ROLE, @Getter> |
  USE_BANG<@ROLE, @Getter>;

private identOrOpName{ROLE, Getter}:
  IDENTIFIER<@ROLE, @Getter> |
  SYMBOLIC_OP<@ROLE, @Getter> |
  activePatternId<@ROLE, @Getter> | 
  longIdentifier<@ROLE, @Getter>;

activePatternId:
  LPAREN<LPAREN, LParen>
  BAR
  (
    activePatternCaseDeclaration<ACTIVE_PATTERN_CASE, Cases>
    BAR
  )+
  RPAREN<RPAREN, RParen>;

longIdentifier:
  IDENTIFIER
  (
    DOT
    IDENTIFIER<IDENTIFIER, Identifiers>
  )*;

interface fSharpIdentifier:
  identifier |
  symbolicOp |
  activePatternId;

abstract identifier options { interfaceName="IFSharpIdentifier"; }:
  IDENTIFIER;

abstract symbolicOp options { interfaceName="IFSharpIdentifier"; }:
  SYMBOLIC_OP;

// Type parameters

typeParameterOfTypeList:
  LESS<LESS,LAngle>
  typeParameterOfTypeDeclaration<TYPE_PARAMETER, TypeParameters>*
  GREATER<GREATER,RAngle>;

typeParameterOfMethodList:
  LESS<LESS,LAngle>
  typeParameterOfMethodDeclaration<TYPE_PARAMETER, TypeParameters>*
  GREATER<GREATER,RAngle>;

typeParameterOfTypeDeclaration options { stubBase="FSharpDeclarationBase"; } extras {
  get { methodName="Attributes" path=<typeParameterOfTypeDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  IDENTIFIER<IDENTIFIER, Identifier>;

typeParameterOfMethodDeclaration options { stubBase="FSharpDeclarationBase"; } extras {
  get { methodName="Attributes" path=<typeParameterOfMethodDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  IDENTIFIER<IDENTIFIER, Identifier>;


// Access modifiers

private accessModifier{ROLE,Getter}:
  PUBLIC<@ROLE,@Getter> |
  PRIVATE<@ROLE,@Getter> |
  INTERNAL<@ROLE,@Getter>;



// Attributes

attributeList:
  LBRACK<LBRACK, LBrack>
  attribute<ATTRIBUTE, Attributes>*
  RBRACK<RBRACK, RBrack>;

attribute options { stubBase="TypeReferenceOwnerBase"; } extras {
  get { methodName="Expression" path=<attribute:CHAMELEON_EXPR/chameleonExpression:EXPR> };
}:
  attributeTarget<ATTR_TARGET, Target>?
  typeReferenceName<REFERENCE_NAME, ReferenceName>
  chameleonExpression<CHAMELEON_EXPR, ArgExpression>?;

attributeTarget:
  IDENTIFIER<IDENTIFIER, Identifier>
  COLON;


fakeSeparator: FAKE;

// Local declarations

localDeclaration options { stubBase="LocalDeclarationBase"; } extras {
  get { methodName="Attributes" path=<localDeclaration:ATTRIBUTE_LIST/attributeList:ATTRIBUTE> };
}:
  attributeList<ATTRIBUTE_LIST, AttributeLists>*
  identOrOpName{IDENTIFIER, Identifier};


interface referenceName:
  expressionReferenceName |
  typeReferenceName;

interface typeArgumentList:
  prefixAppTypeArgumentList |
  postfixAppTypeArgumentList;


postfixAppTypeArgumentList:
  (
    synType<TYPE, Types>
  |
    LPAREN
    synType<TYPE, Types>
    (
      COMMA
      synType<TYPE, Types>
    )*
    RPAREN
 );

prefixAppTypeArgumentList:
  LESS<LESS,LAngle>
  synType<TYPE, Types>
  (
    COMMA
    synType<TYPE, Types>
  )*
  GREATER<GREATER,RAngle>;


expressionReferenceName options { stubBase="ReferenceOwnerBase"; }:
  (
    expressionReferenceName<QUALIFIER, Qualifier>
    DOT<DELIMITER, Dot>
  )?
  fSharpIdentifier<IDENTIFIER, Identifier>
  prefixAppTypeArgumentList<TYPE_ARG, TypeArgumentList>;


typeReferenceName options { stubBase="TypeReferenceOwnerBase"; }:
  (
    postfixAppTypeArgumentList<TYPE_ARG, TypeArgumentList>
    (
      typeReferenceName<QUALIFIER, Qualifier>
      DOT<DELIMITER, Dot>
    )?
    fSharpIdentifier<IDENTIFIER, Identifier>
  |
    (
      typeReferenceName<QUALIFIER, Qualifier>
      DOT<DELIMITER, Dot>
    )?
    fSharpIdentifier<IDENTIFIER, Identifier>
    prefixAppTypeArgumentList<TYPE_ARG, TypeArgumentList>
  );


interface synType:
  namedType |
  tupleType |
  anonRecordType |
  arrayType |
  funType |
  varType |
  anonType |
  otherType;


namedType:
  typeReferenceName<TYPE_REFERENCE, ReferenceName>;

tupleType:
  synType<ITEM, Items>
  (
    STAR
    synType<ITEM, Items>
  )*;

anonRecordType:
  LBRACE_BAR
  anonRecordField<FIELD, Fields>*
  BAR_RBRACE;

anonRecordField:
  expressionReferenceName<REFERENCE_NAME, ReferenceName>
  COLON
  synType<TYPE, Type>;

arrayType:
  synType<TYPE, Type>
  LBRACK
  RBRACK;

funType:
  synType
  RARROW
  synType;

varType options { stubBase="TypeReferenceOwnerBase"; }:
  QUOTE
  IDENTIFIER<IDENTIFIER, Identifier>;

anonType:
  UNDERSCORE;

otherType:
  fakeSeparator;
